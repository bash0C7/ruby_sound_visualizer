<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ruby WASM Sound Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: monospace;
      font-size: 20px;
      text-align: center;
      z-index: 100;
    }
    #status {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
      z-index: 50;
    }
    #vrmUpload {
      margin-top: 30px;
    }
    .vrm-upload-btn {
      display: inline-block;
      padding: 12px 24px;
      background: #222;
      color: #0f0;
      border: 1px solid #0f0;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      transition: background 0.3s, color 0.3s;
    }
    .vrm-upload-btn:hover {
      background: #0f0;
      color: #000;
    }
    #vrmFileName {
      margin-top: 10px;
      font-size: 12px;
      color: #888;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div id="loadingTitle">Loading Ruby WASM Sound Visualizer...</div>
    <div id="loadingStatus" style="font-size: 12px; margin-top: 20px;"></div>
    <div id="vrmUpload" style="display: none;">
      <label for="vrmFileInput" class="vrm-upload-btn">Upload VRM File</label>
      <input type="file" id="vrmFileInput" accept=".vrm" style="display: none;">
      <div id="vrmFileName"></div>
    </div>
  </div>
  <div id="status">
    <div>Ruby WASM Sound Visualizer</div>
    <div id="fpsCounter" style="margin-top: 5px;">FPS: 0</div>
    <div id="debugInfo" style="margin-top: 5px; white-space: pre-wrap;"></div>
    <div id="paramInfo" style="margin-top: 5px;"></div>
    <div id="keyGuide" style="margin-top: 5px; color: #888; font-size: 11px; white-space: pre-wrap;"></div>
  </div>

  <!-- Ruby WASM (must load before async module scripts) -->
  <script src="https://cdn.jsdelivr.net/npm/@ruby/4.0-wasm-wasi@2.8.1/dist/browser.script.iife.js"></script>

  <!-- Import Maps で Three.js 依存関係を解決 -->
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
  }
}
  </script>

  <!-- Three.js とポストプロセッシングをグローバルに登録 -->
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    // Ruby から使えるようにグローバルに登録
    window.THREE = THREE;
    window.EffectComposer = EffectComposer;
    window.RenderPass = RenderPass;
    window.UnrealBloomPass = UnrealBloomPass;
    window.OutputPass = OutputPass;
    window.GLTFLoader = GLTFLoader;
    window.VRMLoaderPlugin = VRMLoaderPlugin;
    window.VRMUtils = VRMUtils;
    window.THREE_READY = true;

    console.log('[Three.js] r' + THREE.REVISION + ' loaded with postprocessing + VRM support');
  </script>

  <!-- Ruby Code Blocks (external files) -->
  <script type="text/ruby" src="src/ruby/math_helper.rb"></script>
  <script type="text/ruby" src="src/ruby/js_bridge.rb"></script>
  <script type="text/ruby" src="src/ruby/frequency_mapper.rb"></script>
  <script type="text/ruby" src="src/ruby/audio_analyzer.rb"></script>
  <script type="text/ruby" src="src/ruby/color_palette.rb"></script>
  <script type="text/ruby" src="src/ruby/particle_system.rb"></script>
  <script type="text/ruby" src="src/ruby/geometry_morpher.rb"></script>
  <script type="text/ruby" src="src/ruby/camera_controller.rb"></script>
  <script type="text/ruby" src="src/ruby/bloom_controller.rb"></script>
  <script type="text/ruby" src="src/ruby/effect_manager.rb"></script>
  <script type="text/ruby" src="src/ruby/vrm_dancer.rb"></script>
  <script type="text/ruby" src="src/ruby/main.rb"></script>

  <script>
    // Global state for JavaScript bridge
    let audioContext, analyser, dataArray;
    let scene, camera, renderer, composer;
    let particleSystem, geometryMesh;
    let bloomPass;
    let lastFrameTime = Date.now();
    let frameCount = 0;

    // VRM state
    let currentVRM = null;
    let vrmMode = false;
    let animLastTime = Date.now();

    // VRM bone order (must match Ruby VRMDancer::BONE_ORDER)
    const VRM_BONE_ORDER = [
      'hips', 'spine', 'chest', 'head',
      'leftUpperArm', 'leftLowerArm', 'leftHand',
      'rightUpperArm', 'rightLowerArm', 'rightHand',
      'leftUpperLeg', 'leftLowerLeg',
      'rightUpperLeg', 'rightLowerLeg'
    ];

    // Ruby VM is set by browser.script.iife.js as window.rubyVM
    const getRubyVM = () => window.rubyVM;

    // Web Audio API Setup
    async function initAudio() {
      console.log('[JS] Initializing Web Audio API...');
      try {
        audioContext = new AudioContext();

        // Chrome のオートプレイポリシー対策: suspended なら resume する
        if (audioContext.state === 'suspended') {
          console.log('[JS] AudioContext is suspended, attempting resume...');
          await audioContext.resume();
          console.log('[JS] AudioContext resumed, state:', audioContext.state);
        }

        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.5;  // ビート検出のため低めに設定
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        console.log('[JS] Web Audio API initialized successfully, context state:', audioContext.state);

        // getUserMedia 後にまだ suspended なら再度 resume
        if (audioContext.state === 'suspended') {
          console.log('[JS] AudioContext still suspended after getUserMedia, retrying resume...');
          await audioContext.resume();
          console.log('[JS] AudioContext state after retry:', audioContext.state);
        }
      } catch (error) {
        console.error('[JS] Audio init error:', error);
        throw error;
      }
    }

    // Three.js Setup
    function initThree() {
      // Three.js モジュールが読み込まれるまで待機
      if (!window.THREE_READY) {
        console.log('[JS] Waiting for Three.js to load...');
        setTimeout(initThree, 100);
        return;
      }

      console.log('[JS] Initializing Three.js...');

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000);
      document.body.appendChild(renderer.domElement);

      // Post-processing setup
      composer = new EffectComposer(renderer);

      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.85
      );
      composer.addPass(bloomPass);

      // OutputPass を追加（最終出力用）
      const outputPass = new OutputPass();
      composer.addPass(outputPass);

      // Particle system
      const particleCount = 3000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 10;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
        colors[i * 3] = 0.3;      // dim gray (グレースケール起動)
        colors[i * 3 + 1] = 0.3;
        colors[i * 3 + 2] = 0.3;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      // Morphing geometry (torus) - ポリゴン削減で FPS 改善（32,64 → 24,32）
      const torusGeometry = new THREE.TorusGeometry(1, 0.4, 12, 16);
      const torusMaterial = new THREE.MeshBasicMaterial({
        color: 0x4d4d4d,  // dim gray (グレースケール起動)
        wireframe: true,
        transparent: true,
        opacity: 0.6,
        emissive: 0x4d4d4d  // dim gray
      });
      geometryMesh = new THREE.Mesh(torusGeometry, torusMaterial);
      scene.add(geometryMesh);

      console.log('[JS] Three.js initialized successfully');
    }

    // VRM file upload promise
    function waitForVRMFile() {
      return new Promise((resolve) => {
        const input = document.getElementById('vrmFileInput');
        input.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (file) {
            document.getElementById('vrmFileName').textContent = file.name;
            resolve(file);
          }
        });
      });
    }

    // Load VRM from File object
    async function loadVRMFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          const arrayBuffer = event.target.result;
          const loader = new GLTFLoader();
          loader.register((parser) => new VRMLoaderPlugin(parser));

          loader.parse(arrayBuffer, '', (gltf) => {
            currentVRM = gltf.userData.vrm;

            VRMUtils.removeUnnecessaryVertices(gltf.scene);
            VRMUtils.removeUnnecessaryJoints(gltf.scene);

            // Position the VRM model at center, slightly lower
            currentVRM.scene.position.set(0, -1.2, 0);

            scene.add(currentVRM.scene);

            // Add lights for VRM materials (does not affect unlit particles/torus)
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(1, 2, 1);
            scene.add(dirLight);
            const ambLight = new THREE.AmbientLight(0x666666);
            scene.add(ambLight);

            // Hide torus in VRM mode
            if (geometryMesh) geometryMesh.visible = false;

            console.log('[JS] VRM model loaded successfully');
            resolve();
          }, (error) => {
            console.error('[JS] VRM load error:', error);
            reject(error);
          });
        };
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    // Update VRM bones from Ruby dance data
    window.updateVRM = function(rotations, hipsY) {
      if (!currentVRM) return;

      const humanoid = currentVRM.humanoid;
      const rotArray = Array.from(rotations || []);
      const hipsPositionY = Number(hipsY) || 0;

      for (let i = 0; i < VRM_BONE_ORDER.length; i++) {
        const boneName = VRM_BONE_ORDER[i];
        const bone = humanoid.getNormalizedBoneNode(boneName);
        if (bone) {
          const rx = Number(rotArray[i * 3]) || 0;
          const ry = Number(rotArray[i * 3 + 1]) || 0;
          const rz = Number(rotArray[i * 3 + 2]) || 0;
          bone.rotation.set(rx, ry, rz);

          // Hips position (bounce) - use set, not accumulate
          if (boneName === 'hips') {
            bone.position.y = hipsPositionY;
          }
        }
      }
    };

    // Update functions called from Ruby
    window.updateParticles = function(positions, colors, avgSize, avgOpacity) {
      if (!particleSystem) {
        console.warn('[JS] particleSystem is not initialized');
        return;
      }

      const posAttr = particleSystem.geometry.attributes.position;
      const colAttr = particleSystem.geometry.attributes.color;

      if (!posAttr || !colAttr) {
        console.warn('[JS] Attributes not found');
        return;
      }

      // Convert to numbers if needed
      const posArray = typeof positions === 'number' ? [positions] : Array.from(positions || []);
      const colArray = typeof colors === 'number' ? [colors] : Array.from(colors || []);

      if (posArray.length > 0 && colArray.length > 0) {
        for (let i = 0; i < posArray.length && i < posAttr.array.length; i++) {
          posAttr.array[i] = Number(posArray[i]) || 0;
        }
        for (let i = 0; i < colArray.length && i < colAttr.array.length; i++) {
          colAttr.array[i] = Number(colArray[i]) || 0;
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;

        // サイズと透明度の動的更新（Ruby で計算済みの平均値を使用）
        if (particleSystem.material) {
          particleSystem.material.size = Number(avgSize) || 0.05;
          particleSystem.material.opacity = Math.max(0.3, Math.min(1.0, Number(avgOpacity) || 0.8));
        }
      }
    };

    window.updateGeometry = function(scale, rotation, emissiveIntensity, color) {
      if (!geometryMesh) {
        console.warn('[JS] geometryMesh is not initialized');
        return;
      }

      const scaleNum = Number(scale) || 1.0;
      geometryMesh.scale.set(scaleNum, scaleNum, scaleNum);

      if (rotation && Array.isArray(rotation) && rotation.length >= 3) {
        geometryMesh.rotation.x = Number(rotation[0]) || 0;
        geometryMesh.rotation.y = Number(rotation[1]) || 0;
        geometryMesh.rotation.z = Number(rotation[2]) || 0;
      }

      // Ruby から渡された色を使用（新規追加）
      if (color && Array.isArray(color) && color.length >= 3 && geometryMesh.material) {
        const r = Number(color[0]) || 0;
        const g = Number(color[1]) || 0;
        const b = Number(color[2]) || 0;

        // Base color
        if (geometryMesh.material.color) {
          geometryMesh.material.color.setRGB(r, g, b);
        }

        // Emissive (色相を保持しつつ intensity で明度制御)
        if (geometryMesh.material.emissive) {
          const intensity = Number(emissiveIntensity) || 0;
          geometryMesh.material.emissive.setRGB(
            r * intensity * 0.5,
            g * intensity * 0.5,
            b * intensity * 0.5
          );
        }
      }
    };

    window.updateBloom = function(strength, threshold) {
      if (!bloomPass) {
        console.warn('[JS] bloomPass is not initialized');
        return;
      }

      bloomPass.strength = Number(strength) || 1.5;
      bloomPass.threshold = Number(threshold) || 0.85;
    };

    window.updateCamera = function(position, shake) {
      if (!camera) {
        console.warn('[JS] camera is not initialized');
        return;
      }

      const pos = Array.isArray(position) ? position : [0, 0, 5];
      const shk = Array.isArray(shake) ? shake : [0, 0, 0];

      camera.position.x = Number(pos[0]) + Number(shk[0]);
      camera.position.y = Number(pos[1]) + Number(shk[1]);
      camera.position.z = Number(pos[2]) + Number(shk[2]);
    };

    window.updateParticleRotation = function(rotation) {
      if (!particleSystem) {
        console.warn('[JS] particleSystem is not initialized');
        return;
      }

      if (rotation && Array.isArray(rotation) && rotation.length >= 3) {
        particleSystem.rotation.x = Number(rotation[0]) || 0;
        particleSystem.rotation.y = Number(rotation[1]) || 0;
        particleSystem.rotation.z = Number(rotation[2]) || 0;
      }
    };

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Delta time for VRM and Ruby
      const animNow = Date.now();
      const deltaTime = (animNow - animLastTime) / 1000;
      animLastTime = animNow;
      window._animDeltaTime = deltaTime;

      if (analyser) {
        analyser.getByteFrequencyData(dataArray);

        if (window.rubyUpdateVisuals) {
          try {
            const freqArray = Array.from(dataArray);
            // Call Ruby update with frequency data
            window.rubyUpdateVisuals(freqArray);
          } catch (error) {
            console.error('[JS] Error calling Ruby update:', error);
          }
        } else {
          console.warn('[JS] rubyUpdateVisuals not available');
        }
      } else {
        console.warn('[JS] analyser not available');
      }

      frameCount++;
      const now = Date.now();
      if (now - lastFrameTime >= 1000) {
        document.getElementById('fpsCounter').textContent = 'FPS: ' + frameCount;
        window.currentFPS = frameCount;  // Ruby に FPS を渡す

        // デバッグ情報表示（Ruby でフォーマット済み）
        if (window.debugInfoText) {
          document.getElementById('debugInfo').textContent = window.debugInfoText;
        }

        // パラメーター情報表示（Ruby でフォーマット済み）
        if (window.paramInfoText) {
          document.getElementById('paramInfo').textContent = window.paramInfoText;
        }

        // キーガイド表示（Ruby でフォーマット済み）
        if (window.keyGuideText) {
          document.getElementById('keyGuide').textContent = window.keyGuideText;
        }

        frameCount = 0;
        lastFrameTime = now;
      }

      // パーティクル回転は Ruby 側で計算済み（updateParticleRotation）

      // VRM model update (spring bones, materials, etc.)
      if (currentVRM) {
        currentVRM.update(deltaTime);
      }

      if (composer) {
        composer.render();
      }
    }

    // Load Ruby code from embedded script tags
    async function loadRubyCode() {
      const rubyBlocks = document.querySelectorAll('script[type="text/ruby"]');
      for (const block of rubyBlocks) {
        const code = block.textContent;
        try {
          if (window.rubyVM) {
            window.rubyVM.eval(code);
            console.log(`[JS] Loaded Ruby code block: ${block.id}`);
          }
        } catch (error) {
          console.error(`Failed to load Ruby code block ${block.id}:`, error);
          throw error;
        }
      }
    }

    function updateLoadingStatus(message) {
      const el = document.getElementById('loadingStatus');
      if (el) {
        el.textContent = message;
      }
      console.log('[JS] ' + message);
    }

    // Initialize everything
    async function init() {
      try {
        // Check for VRM mode
        const urlParams = new URLSearchParams(window.location.search);
        vrmMode = urlParams.has('vrm');

        if (vrmMode) {
          // VRM mode: show upload UI, wait for file, then proceed
          document.getElementById('loadingTitle').textContent =
            'Ruby WASM Sound Visualizer - VRM Mode';
          document.getElementById('vrmUpload').style.display = 'block';
          updateLoadingStatus('Please upload a VRM file to begin...');

          const vrmFile = await waitForVRMFile();
          document.getElementById('vrmUpload').style.display = 'none';

          updateLoadingStatus('Initializing Web Audio API...');
          await initAudio();

          updateLoadingStatus('Initializing Three.js...');
          initThree();

          updateLoadingStatus('Loading VRM model...');
          await loadVRMFile(vrmFile);

          updateLoadingStatus('Ready!');
          document.getElementById('loading').style.display = 'none';
          console.log('[JS] VRM mode initialization complete!');

          animate();
        } else {
          // Normal mode
          updateLoadingStatus('Initializing Web Audio API...');
          await initAudio();

          updateLoadingStatus('Initializing Three.js...');
          initThree();

          // Ruby WASM は browser.script.iife.js によって自動初期化済み
          // window.rubyVM と window.rubyUpdateVisuals は既に利用可能

          updateLoadingStatus('Ready!');
          document.getElementById('loading').style.display = 'none';
          console.log('[JS] Initialization complete!');

          animate();
        }
      } catch (error) {
        console.error('[JS] Initialization error:', error);
        updateLoadingStatus('Error: ' + error.message);
      }
    }

    // AudioContext の suspended 状態をユーザー操作で解除するフォールバック
    document.addEventListener('click', function resumeAudio() {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(function() {
          console.log('[JS] AudioContext resumed by user click, state:', audioContext.state);
        });
      }
      document.removeEventListener('click', resumeAudio);
    });

    // Keyboard event listener for color mode control
    window.addEventListener('keydown', function(event) {
      const key = event.key;
      if (key >= '0' && key <= '3') {
        const keyNumber = parseInt(key, 10);

        if (window.rubySetColorMode) {
          try {
            window.rubySetColorMode(keyNumber);
          } catch (error) {
            console.error('[JS] Error calling rubySetColorMode:', error);
          }
        } else {
          console.warn('[JS] rubySetColorMode not available yet');
        }
      } else if (key === '4' || key === '5') {
        // 4: 色相-5度, 5: 色相+5度（マニュアルシフト）
        if (window.rubyShiftHue) {
          try {
            const delta = (key === '4') ? -5 : 5;
            window.rubyShiftHue(delta);
          } catch (error) {
            console.error('[JS] Error calling rubyShiftHue:', error);
          }
        }
      } else if (key === '6' || key === '7') {
        // 6: 最大輝度-5, 7: 最大輝度+5
        if (window.rubyAdjustMaxBrightness) {
          try {
            const delta = (key === '6') ? -5 : 5;
            window.rubyAdjustMaxBrightness(delta);
          } catch (error) {
            console.error('[JS] Error calling rubyAdjustMaxBrightness:', error);
          }
        }
      } else if (key === '8' || key === '9') {
        // 8: 最大明度-5, 9: 最大明度+5
        if (window.rubyAdjustMaxLightness) {
          try {
            const delta = (key === '8') ? -5 : 5;
            window.rubyAdjustMaxLightness(delta);
          } catch (error) {
            console.error('[JS] Error calling rubyAdjustMaxLightness:', error);
          }
        }
      } else if (key === '-' || key === '+' || key === '=') {
        // +/- で sensitivity を 0.05 ずつ増減（= は Shift なしの + キー対応）
        if (window.rubyAdjustSensitivity) {
          try {
            const delta = (key === '-') ? -0.05 : 0.05;
            window.rubyAdjustSensitivity(delta);
          } catch (error) {
            console.error('[JS] Error calling rubyAdjustSensitivity:', error);
          }
        }
      }
    });

    console.log('[JS] Keyboard listener registered (0-3: color, 4/5: hue, 6/7: brightness, 8/9: lightness, +/-: sensitivity)');

    // Handle window resize
    window.addEventListener('resize', function() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    });

    // Start initialization when page loads
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
