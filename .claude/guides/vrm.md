# VRM Guide

How VRM is used in the current project pipeline.

## Table of Contents

1. [What VRM Is](#what-vrm-is)
2. [VRM File Structure](#vrm-file-structure)
3. [Loading VRM in Three.js](#loading-vrm-in-threejs)
4. [Humanoid Bones](#humanoid-bones)
5. [Expressions](#expressions)
6. [Spring Bones](#spring-bones)
7. [Material Control](#material-control)
8. [VRM Animation Implementation Pattern](#vrm-animation-implementation-pattern)
9. [References](#references)

## What VRM Is

VRM is an avatar-focused format built on glTF.

In this project:
- users can load/unload `.vrm` at runtime
- VRM is optional (visualizer runs without it)
- dance and expression updates are driven from Ruby logic

## VRM File Structure

Typical `.vrm` contains:
- mesh/skin data
- material definitions
- humanoid mapping
- expression definitions
- spring-bone settings

The app treats VRM as runtime user content and does not assume a single fixed model.

## Loading VRM in Three.js

### Libraries used

- `three` (`GLTFLoader`)
- `@pixiv/three-vrm` (`VRMLoaderPlugin`, `VRMUtils`)

### Runtime load sequence

1. User triggers VRM load (`Alt+V` or control panel button).
2. File is read with `FileReader` as `ArrayBuffer`.
3. `GLTFLoader` + `VRMLoaderPlugin` parse the model.
4. `VRMUtils.removeUnnecessaryVertices/Joints` is applied.
5. VRM scene is added, positioned, and scaled.
6. `window.currentVRM` is published for Ruby-side checks.

### Runtime unload

When VRM is already loaded, the same toggle removes it from scene and clears `currentVRM` references.

## Humanoid Bones

The project expects this fixed update order (must match Ruby and JS):

```text
hips, spine, chest, head,
leftUpperArm, leftLowerArm, leftHand,
rightUpperArm, rightLowerArm, rightHand,
leftUpperLeg, leftLowerLeg,
rightUpperLeg, rightLowerLeg
```

Data shape sent from Ruby:
- `rotations`: flat array (`14 bones * 3 axes`)
- `hips_position_y`: scalar

JS applies each triplet with `bone.rotation.set(rx, ry, rz)`.

## Expressions

Current expression updates in `window.updateVRM(...)`:
- blink: `blink`, `blinkLeft`, `blinkRight`
- mouth vertical: `aa`
- mouth horizontal: `ee`

Ruby-side values are generated by `VRMDancer`.

## Spring Bones

Spring behavior is updated with:

```javascript
currentVRM.update(deltaTime)
```

This is called each frame inside the main animation loop when VRM is present.

## Material Control

### Runtime policy

The app updates VRM emissive intensity each frame to match audio-driven energy.

Path:
- Ruby: `VRMMaterialController#apply_emissive`
- JS: `window.updateVRMMaterial(intensity, color)`

### Current JS behavior

`updateVRMMaterial` traverses VRM mesh materials and updates:
- `mat.emissiveIntensity`
- `mat.needsUpdate = true`

Design constraints:
- keep material base setup intact
- only modulate intensity dynamically

### Value range used by current controller

`VRMMaterialController` maps overall energy to approximately:
- base `0.2`
- max `1.0`

## VRM Animation Implementation Pattern

### Current approach

`VRMDancer` uses time-driven procedural motion rather than direct per-frame audio amplitude matching for body pose.

Key characteristics:
- multi-phase sinusoidal motion channels
- separate blink timer and mouth cycles
- per-axis smoothing via `MathHelper.lerp`
- final rotation amplification for visible stage motion

### Why this approach

- stable dance cadence even with sparse/noisy audio
- expressive movement without requiring external animation clips
- predictable output for Ruby-side testing

### Audio relation

Audio is still used elsewhere (geometry, particles, bloom, camera), while VRM body rhythm remains intentionally stylized and continuous.

## References

- [VRM](https://vrm.dev/)
- [VRM Specification](https://github.com/vrm-c/vrm-specification)
- [three-vrm](https://github.com/pixiv/three-vrm)
- [three-vrm Docs](https://pixiv.github.io/three-vrm/)
